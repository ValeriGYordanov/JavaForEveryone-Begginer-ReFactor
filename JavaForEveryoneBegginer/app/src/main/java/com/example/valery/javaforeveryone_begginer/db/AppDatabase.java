package com.example.valery.javaforeveryone_begginer.db;

import android.arch.persistence.room.Database;
import android.arch.persistence.room.Room;
import android.arch.persistence.room.RoomDatabase;
import android.content.Context;

import com.example.valery.javaforeveryone_begginer.model.Stage;
import com.example.valery.javaforeveryone_begginer.model.StageDao;
import com.example.valery.javaforeveryone_begginer.model.User;
import com.example.valery.javaforeveryone_begginer.model.UserDao;
import com.fstyle.library.helper.AssetSQLiteOpenHelperFactory;

/**
 * Created by Valery on 3/6/2018.
 */
@Database(entities = {User.class, Stage.class}, version = 1, exportSchema = false)
public abstract class AppDatabase extends RoomDatabase {

    private static AppDatabase instance;

    public static AppDatabase getInstance(Context ctx) {
        if (instance == null){
//            instance = Room.databaseBuilder(ctx.getApplicationContext(), AppDatabase.class, "appdb.db")
//                    .build();
            instance = Room.databaseBuilder(ctx.getApplicationContext(), AppDatabase.class, "appdb.db")
                    .openHelperFactory(new AssetSQLiteOpenHelperFactory()).build();
        }

        return instance;
    }

    public abstract UserDao userModelDAO();
    public abstract StageDao stageDao();

    //String arrays = "<p style=text-align: center;><strong>Масиви</strong></p><p style=text-align: center;>За да избегнем писането на<br />голямо количество код и<br />огромното повторение, което е<br />лоша практика в<br />програмирането, Јаvа ни дава<br />механизъм за лесно създаване на<br />много променливи наведнъж,<br />конструкцията масив.</p><p style=text-align: center;><strong>Допълнителна</strong><br /><strong>информация</strong></p><p style=text-align: center;><em><strong>Какво съдържа</strong></em><br /><em><strong>масива?</strong></em></p><p style=text-align: center;>Масивите могат да съдържат<br />множество от данни които имат<br />един и същи тип!</p><p style=text-align: center;><strong>Масиви - Полза</strong></p><p style=text-align: center;>Елементите в масива са от един<br />и същи тип - Int, char, boolean и<br />др. веднъж създаден, масивът<br />не променя размера си.<br />Декларирането на масив се<br />осъществява:<br />&lt;типа на елементите в масива&gt;<br />[] &lt;име на масива &gt;.</p><p style=text-align: left; padding-left: 270px;><em>public class Snippets{</em></p><p style=text-align: left; padding-left: 270px;><em>&nbsp; &nbsp;public static void main(String[] args) {</em><br /><em>&nbsp; &nbsp; &nbsp; int [] аггау = new int [5];</em></p><p style=text-align: left; padding-left: 270px;><em>&nbsp; &nbsp;}</em><br /><em>}</em></p><p style=text-align: center;><br />Създаденият горе масив<br />съдържа елементи от тип<br />Int, като самия масив се състои<br />от 5 елемента.</p><p style=text-align: center;>&nbsp;</p><p style=text-align: center;>При достъпване на елемент от<br />масива е нужно да знаем<br />неговият индекс, поредния му<br />номер като индексите му<br />започват от 0. Можем да вземем<br />броя на елементите на масив<br />използвайки конструкцията &lt;<br />име на масив&gt;.length() За да<br />обходим масив използваме<br />цикъл, най-често for цикъл - За<br />който ще говорим в друг етап.</p><p style=text-align: left; padding-left: 270px;><em>public class Snippets {</em><br /><em>&nbsp; &nbsp;public static void main(String[] args) {</em><br /><em>&nbsp; &nbsp; &nbsp; int [] аггау = {1,2,3,4,5};</em><br /><em>&nbsp; &nbsp; &nbsp; System.out.println(аггау[2]);</em></p><p style=text-align: left; padding-left: 270px;><em>&nbsp; &nbsp;}</em><br /><em>}</em></p><p style=text-align: center;>Горната конструция би<br />изписала 3 на конзолата.<br /><strong>Помислете защо?</strong></p><p style=text-align: center;>&nbsp;</p><p style=text-align: center;><strong>Двумерни Масиви</strong></p><p style=text-align: center;>Съществуват и двумерни<br />масиви или с други думи масив<br />съдържащ друг масив в себе си.</p><p style=text-align: center;>Пример:<br />int[][] sample = {{1,2,З}, {4,5,6}};</p><p style=text-align: center;>Можем да си го представим като<br />адрес или по точно :<br />Номер на блок,в блока има етажи.<br />Със същия пример може да си<br />отговорим на въпроса дали<br />може да има тримерен и по -<br />дълбок масив? <br />- Да!<br />Номер на блок с номер на етаж<br />и номер на апартамент.</p><p style=text-align: center;>Направете опит да вземете<br />някакво число от по дълбок<br />масив</p>";
    //String strings = "<p style=text-align: center;><strong>Символни Низове</strong></p><p style=text-align: center;>В Java типът String се използва за<br />променливи, които съхраняват<br />текст под формата на символен<br />низ.</p><p style=text-align: center;>Променливите от тип String са<br />непроменими(Immutable) и данните<br />са от референтен тип,<br />стойностите се съхраняват в<br />Хийпа.(Неар). На следващата<br />страница може да видите графика<br />на съдържане променливите в<br />паметта - Stack и Неар</p><p style=text-align: center;>Друг такъв тип данни е<br />StringBuilder За който<br />ще поговорим след<br />малко.</p><p>&nbsp;</p><p style=text-align: center;><strong>String Poo</strong>l</p><p style=text-align: center;>сенамира в Неар-а ,<br />но е отделен от останалата информация.<br />За да пести памет низовите<br />литерали се съхраняват в<br />отделен отсек наречен String Pool, <br />когато инициализираме<br />нова променлива чрез низов<br />литерал(=), се проверява дали<br />такъв низ вече не е бил<br />създаден преди и се намира в<br />String Pool-а. Ако да, тогава<br />пренасочва референцията към<br />него. Така 2 String-а с различна<br />за нас референция и стойност<br />Some Text ще сочат към едно и<br />също място в Неар-а.</p><p style=text-align: center;>String and ==</p><p style=text-align: center;>Друг начин за създаване на<br />String с ключовата дума пеш,<br />като тогава се създава нов<br />символен низ без да се<br />проверява дали го има вече в<br />Pool-а. При създаване с new и<br />сравнение с == връща False<br />тъй като е референтен тип<br />данни и сравнява адресите, а<br />не стойностите.</p><p style=text-align: center;>public class Snippets {<br />public static void main(String[] args) {<br />String text = &ldquo;Some Text;<br />String text2 = new String(&ldquo;Some Text);<br />System.out.println(text == text2);</p><p style=text-align: center;>}<br />}</p><p style=text-align: center;>Въпреки че двата текста са еднакви в<br />конзолата би се изписало - false, тъй като<br />вторият String (text2) се създава <br />с ключовата дума new</p><p style=text-align: center;>String and Equals()</p><p style=text-align: center;>След като == не би ни<br />свършило работа в<br />сравнението на 2 нива.</p><p style=text-align: center;>Друг начин за сравняване на<br />низове е методът equals() -<br />методът взима двата нива и ги<br />сравнява буква по буква</p><p style=text-align: center;>public class Snippets {<br />public static void main(String[] args) {<br />String text = &ldquo;Some Text;<br />String text2 = new String(&ldquo;Some Text);<br />System.out.println(text.equals(text2));</p><p style=text-align: center;>}<br />}</p><p style=text-align: center;>}</p><p style=text-align: center;>В този случай, на конзолата би<br />се изписало - true. Тъй като ги<br />сравняваме буква по буква.</p><p style=text-align: center;>String - методи</p><p style=text-align: center;>Има методи за промяна на<br />буквите от малки към големи и<br />обратно, да прочетем<br />следващият ред, да разделим<br />низа по определен критерии,<br />Можем да слепваме думи с<br />метода concat() или с +<br />(Не е пропоръчително да<br />събираме множество<br />литерали в String<br />- Виж Immutability),</p><p style=text-align: center;>да обхождаме низа буква по<br />буква и др.</p><p style=text-align: center;>Някои от методите:</p><p style=text-align: center;>.toUpperCase() - всички букви стават<br />големи.</p><p style=text-align: center;>.toLowerCase() - всички букви стават<br />малки.</p><p style=text-align: center;>.toCharArray() - превръща нива в масив<br />от тип character.</p><p style=text-align: center;>Може да видите и другите методи<br />в Eclipse.</p><p style=text-align: center;>StringBuilder</p><p style=text-align: center;>StringBuilder е друг начин за<br />създаване на символни<br />низове, той е mutable<br />(можем да променяме<br />създадения низ) използва<br />методи за слепване,<br />изтриване. Тъй като той<br />е променим, при него не е<br />проблем да слепваме<br />множество литерали.</p>";
    //String algorithms = "<p style=text-align: center;>Програмирането се състои<br />от проблеми, които е нужно<br />да научим как се решават. За<br />да решим един голям проблем<br />е необходимо да го разбием<br />на по-малки такива.<br />Алгоритъм наричаме<br />съвкупност от операции,<br />подредени в определен ред,<br />посредством които се<br />решава даден проблем.<br />Всеки алгоритъм има т.нар.<br />най-малка съставна част,<br />стъпка, чието решение е<br />тривиално.</p><p style=text-align: center;>Алгоритъм е дори стигането<br />от вкъщи до работа. Разделен<br />на части - Излизане от<br />вкъщи пътуване до мястото<br />&nbsp;на работа, влизане в сградата!</p><p style=text-align: center;>Които задачи от своя страна<br />също са кратки алгоритми.</p><p style=text-align: center;>&nbsp;</p><p style=text-align: center;>Сложността на алгоритъм<br />се изчислява посредством<br />сложността си по време и<br />сложността си по памет.</p><p style=text-align: center;>Сложност по време<br />представлява степента на<br />изменение на времето за<br />изпълнение на алгоритъма<br />спрямо изменението на<br />обема от входни данни.<br />Сложност по памет<br />представлява степента на<br />изменение в заетата памет<br />от алгоритъма спрямо<br />изменението на обема от<br />входни данни.</p><p style=text-align: center;><strong>Константна сложност - о(1)</strong></p><p style=text-align: center;><br />Константна сложност имат<br />алгоритми, които не променят<br />времето за изпълнение и<br />заетата памет при изменение<br />на входните данни. Те са<br />най-бързите алгоритми.<br />Пример: взимането на З-тият<br />елемент от масив. Без<br />значение колко голям е масива,<br />ние винаги ще взимаме З-тият<br />елемент.</p><p style=text-align: center;><br /><em>for(int i = 0; i &lt; arr.length(); i++) {</em><br /><em>System.out.println(arr [2]) ;</em><br /><em>}</em></p><p style=text-align: center;>&nbsp;</p><p style=text-align: center;><strong>Линейна сложност - o(N)</strong></p><p style=text-align: center;><br />Алгоритми, при които времето<br />или паметта се изменят<br />толкова, колкото се изменя и<br />обемът на входните данни.</p><p style=text-align: center;>for (int i = 0; І &lt; arr.length(); i++) {<br />System.out.println(arr [i]);<br />}</p><p style=text-align: center;>Така в зависимост от големината<br />на масива, зависят и броят<br />операции които нашият<br />цикъл ще направи.</p><p style=text-align: center;><strong>Логаритмична сложност o(logN)</strong></p><p style=text-align: center;>Алгоритми, които<br />изпълняват logNоперации при<br />N на брой входни данни, като<br />степента на логаритъма не се<br />обозначава.</p><p style=text-align: center;>Scanner sc = new Scanner(System.in);<br />int n = sc.nextInt();<br />for(int i = 0; i &lt; n ; i*=2){<br />System.out.println(i)</p><p style=text-align: center;>Опитайте следният код<br />във ваша програма.</p><p style=text-align: center;><strong>o(NlogN)</strong></p><p style=text-align: center;>Често срещана<br />сложност използвана от едни<br />от най-добрите сортиращи<br />алгоритми.</p><p style=text-align: center;>Scanner sc = new Scanner(System.in);<br />int n = sc.nextInt();<br />for(int i = 1; i &lt; n; i++){<br />for(int j = 1; j &lt; n; j*=2){<br />System.out.println( i +  = i  + j +  = j);<br />}<br />}</p><p style=text-align: center;>&nbsp;</p><p style=text-align: center;>При определяне на сложността на<br />алгоритми константите не се<br />взимат впредвид.<br />Сложност в различни ситуации.<br />Сложност при най-благоприятни<br />условия - Best case complexity.<br />Изчислява се, когато за входни<br />данни вземем най-удобните<br />стойности.</p><p style=text-align: center;>Сложност при<br />най-неблагоприятни случай -<br />Worst case complexity. Когато за<br />входни данни вземем<br />най-неудобните стойности.<br />Сложност в средния случай<br />Average Case Complexity. Когато<br />вземем за входни данни<br />абсолютно произволна<br />комбинация от стойности и<br />пресметнем средно колко на<br />операции ще имаме, когато тези<br />стойности се променят.</p><p>&nbsp;</p>";



}
